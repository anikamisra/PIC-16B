<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.541">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anika Misra">
<meta name="dcterms.date" content="2024-02-06">

<title>myblog - How to use Python and Scrapy to determine movies you will like based on Legally Blonde</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">myblog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">How to use Python and Scrapy to determine movies you will like based on Legally Blonde</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">week 4</div>
                <div class="quarto-category">homework2</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Anika Misra </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 6, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="how-to-use-python-and-scrapy-to-determine-movies-you-will-like-based-on-legally-blonde" class="level1">
<h1>How to use Python and Scrapy to determine movies you will like based on Legally Blonde</h1>
<p>Welcome! In today’s post, I will be describing how to build a webscraper to scrape the TMDB movie database. By the end of this post, you should understand how to build a webscraper, and you should be able to use this webscraper for the movie of your choice to find recommendations based on it. For my movie, I’m going to choose <em>Legally Blonde</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="reese-witherspoon-as-elle-woods-2-1549299125.gif" title="segment" class="img-fluid figure-img"></p>
<figcaption>SegmentLocal</figcaption>
</figure>
</div>
<p><a href="https://www.seventeen.com/celebrity/movies-tv/a26132769/legally-blonde-3-news/">Image source</a></p>
<p>What a girlboss!!</p>
</section>
<section id="part-a-building-the-webscraper" class="level1">
<h1>Part A: Building the webscraper</h1>
<section id="part-0a-initializer" class="level2">
<h2 class="anchored" data-anchor-id="part-0a-initializer">Part 0A: Initializer</h2>
<p>Just like Elle Woods had to study hard for her LSAT before she got into Harvard, we all have to start somewhere. Before webscraping the TMDB website, we have to build our scraper. In this section, I will explain <em>how</em> to build the scraper and <strong>how the scraper works</strong>. Then, in part B, I will explain <em>where</em> this TmdbSpider class should go and <em>how to actually set up the scraper</em> in your local computer. So for now, just follow along with the explanation, and we will set everything up in Part B.</p>
<p>We begin this webscraper by importing the necessary packages, defining a class, and constructing the initializer.</p>
<p>We will name the class <strong>TmdbSpider</strong> since we are creating a webscraper for the TMDB database. It will inherit the class scrapy.Spider.</p>
<p>In the initializer, we will accept a “subdir” string argument. This argument is a string that contains the last part of the url the movie we want to scrape. It should look something like this:</p>
<p>“8835-legally-blonde”</p>
<p>This url ending can be found by looking at the url of the movie we want to scrape on the TMDB website.</p>
<p>Then, we will create an instance variable called <strong>start_urls</strong> that builds the complete url for the movie to scrape.</p>
<div id="988704aa-7312-4aed-8146-8772c9a23ab4" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import necessary packages </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scrapy </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># define a class that inherits scrapy.Spider, the base class for spiders </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TmdbSpider(scrapy.Spider):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> <span class="st">'tmdb_spider'</span> <span class="co"># name our spider </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, subdir<span class="op">=</span><span class="va">None</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Class constructor for the TmdbSpider class. </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Args: </span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">            self (TmdbSpider class instance): instance of the TmdbSpider class. </span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">            subdir (string): String for the subdirectory of the movie we want to start with. This string can be found in the movie url </span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">            *args: additional arbitrary keyword arguments </span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">            **kwargs: additional keyword arguments  </span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">            </span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start_urls <span class="op">=</span> [<span class="ss">f"https://www.themoviedb.org/movie/</span><span class="sc">{</span>subdir<span class="sc">}</span><span class="ss">/"</span>] <span class="co"># build the complete url from the subdirectory </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="part-1a-parse-method" class="level2">
<h2 class="anchored" data-anchor-id="part-1a-parse-method">Part 1A: Parse Method</h2>
<p>The first class method we will define is the parse() function. This is how the parse() function works:</p>
<ol type="1">
<li>First, obtain the url of the full cast and crew. This will be done by “hardcoding”, aka, manually adding a “cast” string onto our <strong>start_urls</strong> instance variable.</li>
<li>Call the parse_full_credits() method. This will be done by specifying a callback argument to a yielded scrapy request.</li>
</ol>
<p>This method assumes we start on a movie page, and it should navigate us to a “full cast and crew” page for that specific movie. Then, it calls the next parse function, which we will define in part 2.</p>
<div id="4eb2d499-db9e-4c89-8e91-2dc340554d80" class="cell" data-tags="[]" data-execution_count="23">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(<span class="va">self</span>, response): </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">        Assumptions: </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">            Assume we are starting on a movie page. </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">        Effects: </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">            Navigate to a "full cast and crew" page for that specific movie. </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">            Data outputs: A yielded scrapy request calling parse_full_credits() method with the harcoded "full cast and crew" url </span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># first, obtain the url of full cast and crew (hardcoded)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># response.url is a built-in method that gives us current url of response</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        cast_url <span class="op">=</span> response.url <span class="op">+</span> <span class="st">'/cast/'</span>  </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># parse_full_credits method is called by specifying callback argument to yielded scrapy request</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> scrapy.Request(url <span class="op">=</span> cast_url, callback <span class="op">=</span> <span class="va">self</span>.parse_full_credits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="important" class="level2">
<h2 class="anchored" data-anchor-id="important">Important:</h2>
<p>Please note that each of the parse methods we are defining are all part of the <strong>TmdbSpider class</strong>!!!</p>
<section id="anyways" class="level4">
<h4 class="anchored" data-anchor-id="anyways">Anyways…</h4>
<p>What just happened in the last line? Well, in the “yield scrapy.Request” line, we first tell scrapy to fetch this url. After it fetches the “full cast and crew” url, we obtain the response object. This response object is automatically passed in as the second argument to the callback function, parse_full_credits. And, remember from PIC16A that “self” is always passed in as the first argument. This is why <strong>parse_full_credits</strong> function has no arguments specified.</p>
<p><strong>parse_full_credits</strong>: 1. First argument: self (automatic) 2. Second argument: response object from cast_url (automatic)</p>
<p>What does the parse_full_credits() method do? Well, let’s define it now!</p>
</section>
</section>
<section id="part-2a-parse-full-credits-method" class="level2">
<h2 class="anchored" data-anchor-id="part-2a-parse-full-credits-method">Part 2A: Parse full credits Method</h2>
<p>The second class method we will define is parse_full_credits(). This function takes in two arguments: a reference to the current instance of the class “self”, and the response object generated from the previous parse method. It assumes we start on the “full cast and crew” wegpage for a specific movie. Here is how it works:</p>
<ol type="1">
<li><strong>Locate the “cast” table of the webpage.</strong></li>
</ol>
<ul>
<li>To do this, we will search for an h3 element containing “Cast” using Xpath.</li>
<li>We must ensure we are only in the cast table, or else we might get non-actors in our list (aka, members from the production crew).</li>
</ul>
<ol start="2" type="1">
<li><strong>Obtain the list of cast members.</strong></li>
</ol>
<ul>
<li>Select the first “ordered list” (ol) element that appears after the h3 element. We can do this using “following-sibling::ol[1]”.</li>
<li>Note that the ordered list element is not a “child” of the h3 element, which is why we use the “following-sibling” expression.</li>
</ul>
<ol start="3" type="1">
<li><strong>Obtain the actor urls.</strong></li>
</ol>
<ul>
<li>Using the xpath object of cast members, navigate into the list element that contains a div element with a class attribute containing “info”.</li>
<li>Then, look for a &lt;&gt; tag after the div class. This &lt;&gt; tag may or may not be the direct descendent of the div element, which is why we use the “descendant-or-self” line.</li>
<li>Finally, navigate into the &lt;&gt; tag and grab the url inside it. Use the “getall()” method to obtain all such links.</li>
</ul>
<ol start="4" type="1">
<li><strong>Yield scrapy requests for each actor url, using the parse_actor_page method as a callback function.</strong></li>
</ol>
<p>Here is what the function should look like.</p>
<div id="674c4825-65e7-4b20-9c37-0b6d516d38f9" class="cell" data-tags="[]" data-execution_count="24">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response): </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">        Assumptions: </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">            Assume we are starting on a "full cast and crew" page for one movie. </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">        Effects: </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">            Navigate to each actor's page for the specific movie (note - ACTOR - not any other crew member!) </span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">            Data outputs: A yielded scrapy request calling parse_actor_page() method for every single actor's link in this webpage. </span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Locate cast table of webpage (h3 tag contains "Cast")  </span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Create an xpath object from this "Cast" table, called table1 </span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        table1 <span class="op">=</span> response.xpath(<span class="st">'//h3[contains(., "Cast")]/following-sibling::ol[1]'</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 3: Obtain all the actor urls by finding the proper link for each actor  </span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        urls_actors <span class="op">=</span> table1.xpath(<span class="st">'.//li//div[contains(@class, "info")]/descendant-or-self::*/p/a/@href'</span>).getall()</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># notice that we use getall() method to obtain ALL actor urls </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 4: Yield scrapy requests for each actor url </span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> link <span class="kw">in</span> urls_actors: </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> scrapy.Request(url <span class="op">=</span> response.urljoin(link), callback <span class="op">=</span> <span class="va">self</span>.parse_actor_page) </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># we use urljoin as opposed to simple string concatonation to ensure that relative urls are formed properly </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is what the HTML element looks like. In this HTML element, we are trying to obtain the <em>second</em> “a href=”/person/368-reese-witherspoon” text to get the link for the actor page. We specifically try to get the second one, and not the first one, because each actor has two links and we do not want more than one link per actor.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/1addbc9d-3399-454b-8efc-f3b08b4afa63-1-a957588d-84c2-4dd9-9ed2-8fb354ddf940.png" class="img-fluid figure-img"></p>
<figcaption>Screenshot 2024-02-05 at 1.31.27 PM.png</figcaption>
</figure>
</div>
<p>In our function, just like before, we do not put any arguments into the <strong>parse_actor_page()</strong> function because the second argument is automatically the response object fetched by the url we specified, and the first argument is automatically “self”. But what is the <strong>parse_actor_page()</strong> function? Let’s define it right now!</p>
</section>
<section id="part-3a-parse-actor-page" class="level2">
<h2 class="anchored" data-anchor-id="part-3a-parse-actor-page">Part 3A: Parse actor page</h2>
<p>The final class method we will define is the <strong>parse_actor_page()</strong> method. This function takes in two arguments, (1) a reference to the current instance of the class “self”, and (2) the response object generated from the previous class method we defined. It assumes we start on an actor’s webpage. It will yield a dictionary object for each actor and each movie they played in. Here is how it works:</p>
<ol type="1">
<li>Get the actor’s name: It will be on the very top of the webpage in the &lt;&gt; title element.</li>
<li>Locate the “acting” table in the actor’s webpage and create an xpath object from it called “table”.</li>
</ol>
<ul>
<li>We do this by first finding the h3 element with text element “Acting”, and then we select the element that occurs directly after it.</li>
<li>This is why we use the “following-sibling” code.</li>
</ul>
<ol start="3" type="1">
<li>Obtain each movie / tv show name from the acting “table”.</li>
</ol>
<ul>
<li>This is done by navigating to the &lt;&gt; element within the acting “table”.</li>
</ul>
<ol start="4" type="1">
<li>Yield a key-pair value containing {actor_name, movie_or_TV_name} for every movie / tv show that the actor played in.</li>
</ol>
<div id="3c6de7bf-01e7-43f8-ae50-f3f644c640f4" class="cell" data-tags="[]" data-execution_count="25">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response): </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">        Assumptions: </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">            Assume we are starting on an actor's webpage. </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">        Effects: </span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">            Does not navigate to any new webpages.  </span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">            Data outputs: A yielded dictionary, each key-value pair containing the movie that an actor acted in along with the actor's name. </span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: obtain the actor's name from the Title of the webpage </span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        actor_name <span class="op">=</span> response.css(<span class="st">'h2.title &gt; a::text'</span>).get()</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Locate the acting table in the webpage, and select the element that occurs immediately after it </span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        table <span class="op">=</span> response.xpath(<span class="st">'//h3[text()="Acting"]/following-sibling::table[1]'</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 3: Obtain the relevant movie / tv show names from each acting "table"  </span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        movie_names <span class="op">=</span> table.css(<span class="st">'td.role.true.account_adult_false.item_adult_false &gt; a.tooltip &gt; bdi::text'</span>).getall()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># notice that we use "getall()" method to obtain ALL movie / tv show names  </span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Yield a key-value pair for each movie / tv show in this actor's webpage </span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> movie_or_TV_name <span class="kw">in</span> movie_names: </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> {<span class="st">"actor"</span>: actor_name, <span class="st">"movie_or_TV_name"</span>: movie_or_TV_name} </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is what the HTML element looks like. In this HTML element, we are trying to obtain the text within the &lt;&gt; element because that gives us the movie / tv show name.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/8afa320d-a405-48e4-bbbc-35831fb0292e-1-d8558a26-e29e-4b60-acd9-7d44d8302080.png" class="img-fluid figure-img"></p>
<figcaption>Screenshot 2024-02-05 at 5.19.29 PM.png</figcaption>
</figure>
</div>
</section>
</section>
<section id="part-b-project-finding-recommendations-based-on-legally-blonde" class="level1">
<h1>Part B: Project: Finding Recommendations based on Legally Blonde</h1>
<section id="part-0b-setting-up-scraper" class="level2">
<h2 class="anchored" data-anchor-id="part-0b-setting-up-scraper">Part 0B: Setting up scraper</h2>
<p>Now that we know how to build our TMDB Spider, let’s actually set it up and use it to find recommendations based on Legally Blonde. The first step is to set up your local machine for webscraping. Here are the first few steps:</p>
<p>In your terminal, 1. Activate the Python environment of your choice 2. Navigate into the directory where you want your scraper files to be<br>
3. Run the following lines in your terminal:</p>
<p>scrapy startproject TMDB_scraper cd TMDB_scraper</p>
<p>This will create a lot of folders and files. Do not worry about these. Here are the next steps: 1. Inside your spider directory, add a file called “tmdb_spider.py”. <strong>Inside this file, write out the tmdbSpider class we just defined</strong>. 2. In your settings.py file, add this line: “USER_AGENT = ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0’”. This will ensure we do not run into any 403 errors.</p>
</section>
<section id="part-1b-running-the-scraper" class="level2">
<h2 class="anchored" data-anchor-id="part-1b-running-the-scraper">Part 1B: Running the scraper</h2>
<p>Now, we will run our scraper for <em>Legally Blonde</em>. The TMDB link for Legally Blonde is:</p>
<p>https://www.themoviedb.org/movie/8835-legally-blonde</p>
<p>So, our “subdir” argument should be <strong>8835-legally-blonde</strong>. Navigate into the directory where you want your results file to be, and run the following line in your terminal:</p>
<p>scrapy crawl tmdb_spider -o results.csv -a subdir=8835-legally-blonde</p>
<p>This line will webscrape the Legally Blonde database using the <strong>tmdb spider class</strong> we just defined. The “subdir” argument is passed into the very first “parse” method, and the webscraper navigates to the appropriate webpages from there.</p>
</section>
<section id="part-2b-accessing-and-analyzing-results.csv-file" class="level2">
<h2 class="anchored" data-anchor-id="part-2b-accessing-and-analyzing-results.csv-file">Part 2B: Accessing and analyzing results.csv file</h2>
<p>After running this line in your terminal, wait till you see a message that the Spider has closed in your terminal. Then, in the folder that you are currently in, there should be a file called “results.csv”. This should contain two columns: 1. Actor name 2. Movie name</p>
<p>Now, let’s analyze these results to build a recommender system.</p>
<p>First, let’s import this results.csv file and turn it into a pandas dataframe for easy analysis.</p>
<div id="b148edc5-e603-40f8-b412-0968ac0e6fb1" class="cell" data-tags="[]" data-execution_count="26">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import pandas </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># import results csv file as dataframe </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.read_csv(<span class="st">"results.csv"</span>) </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># preview results dataframe</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>results.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">movie_or_TV_name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Reese Witherspoon</td>
<td>Tiny Trailblazers</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Reese Witherspoon</td>
<td>Tracy Flick Can't Win</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Reese Witherspoon</td>
<td>Great Performers: 9 Kisses</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Reese Witherspoon</td>
<td>You’re Cordially Invited</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Reese Witherspoon</td>
<td>Legally Blonde 3</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Great! Let’s see how many actors were in the original “Legally Blonde” movie, and how many total actors and movie / TV show names there are.</p>
<div id="ed0f3171-8179-435a-8834-160c968a1dbb" class="cell" data-tags="[]" data-execution_count="27">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>actors_in_legally_blonde <span class="op">=</span> results[results[<span class="st">'movie_or_TV_name'</span>] <span class="op">==</span> <span class="st">'Legally Blonde'</span>][<span class="st">'actor'</span>].unique()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>movies_total <span class="op">=</span> results[<span class="st">'movie_or_TV_name'</span>].unique()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All the actors in Legally Blonde: </span><span class="ch">\n</span><span class="st">"</span>, actors_in_legally_blonde, <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All the movies that are in the results file: </span><span class="ch">\n</span><span class="st">"</span>, movies_total, <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of movies / TV shows in the results file: </span><span class="ch">\n</span><span class="st">"</span>, results[<span class="st">'movie_or_TV_name'</span>].nunique())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>All the actors in Legally Blonde: 
 ['Reese Witherspoon' 'Lily' 'Kelly Driscoll' 'Sasha Barrese' 'Moonie'
 'Kennedy Stone' 'Elizabeth Matthews' 'Richard Hillman' 'John Kapelos'
 'Patricia Kimes' 'Jodi Harris' 'Nectar Rose' 'Terence Michael'
 'John Cantwell' 'Ondrea de Vincentis' 'Chaney Kley' 'Melissa Anne Young'
 'Brody Hutzler' 'Lacey Beeman' 'Jason Christopher' 'Lisa K. Wyatt'
 'Corinne Reilly' 'Doug Spinuzza' 'Niklaus Lange' 'Victoria Mahoney'
 'Tane McClure' 'David Moreland' 'Allyce Beasley' 'Kevin Cooney'
 'Cici Lau' 'Natalie Barish' 'Lisa Arch' 'Francesca P. Roberts'
 'Kimberly McCullough' "Shannon O'Hurley" 'Ted Rooney' 'Kelly Nyks'
 'Samantha Lemole' 'Michael B. Silver' 'Ted Kairys' 'Bruce Thomas'
 'Meredith Scott Lynn' 'Linda Cardellini' 'Raquel Welch' 'Greg Serano'
 'Osgood Perkins' 'Wayne Federman' 'Jessica Cauffiel' 'Alanna Ubach'
 'Victor Garber' 'James Read' 'Jennifer Coolidge' 'Holland Taylor'
 'Matthew Davis' 'Selma Blair' 'Luke Wilson' 'Ali Larter'] 

All the movies that are in the results file: 
 ['Tiny Trailblazers' "Tracy Flick Can't Win" 'Great Performers: 9 Kisses'
 ... 'Giving It Up' 'Varsity Blues' 'Just Shoot Me!'] 

Number of movies / TV shows in the results file: 
 1775</code></pre>
</div>
</div>
</section>
<section id="part-3b-building-our-recommender-system" class="level2">
<h2 class="anchored" data-anchor-id="part-3b-building-our-recommender-system">Part 3B: Building our recommender system</h2>
<p>There are 1775 movies/TV shows to choose from! How do we know which one we will like best? One way to do this is to see which movies / TV shows have the highest number of <strong>shared actors</strong> with Legally Blonde. Then, we can create a visualization with the top 10 movies / TV shows and the number of shared actors they contain.</p>
<p>Let’s make this visualization <strong>pink</strong>, Elle Woods’ favorite color!!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/0191c73d-442c-4dfe-970a-883ef2923e8f-1-2fcc716b-8b5a-4bef-9d45-9f426191129a.jpg" class="img-fluid figure-img"></p>
<figcaption>Image 2-5-24 at 6.40 PM.jpg</figcaption>
</figure>
</div>
<p><a href="https://legallyblonde.fandom.com/wiki/Elle_Woods">Image source</a></p>
<div id="e149d615-0f07-4323-93e2-8d01d5d3cc24" class="cell" data-tags="[]" data-execution_count="28">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import matplotlib </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create a new dataframe for shared actors </span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>same_actors <span class="op">=</span> results[results[<span class="st">'actor'</span>].isin(actors_in_legally_blonde) <span class="op">&amp;</span> (results[<span class="st">'movie_or_TV_name'</span>] <span class="op">!=</span> <span class="st">'Legally Blonde'</span>)] </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># find out how many shared actors per movie </span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>same_actors_value <span class="op">=</span> same_actors[<span class="st">'movie_or_TV_name'</span>].value_counts()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># create a new dataframe with top 10 movies / TV shows </span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>top_movie_TV_show <span class="op">=</span> same_actors_value.nlargest(<span class="dv">10</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># plot bar chart accordingly </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure the color is pink! </span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>top_movie_TV_show.plot(kind<span class="op">=</span><span class="st">'bar'</span>, color<span class="op">=</span><span class="st">'pink'</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Most recommended movies / TV shows for you based on Legally Blonde'</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Movie / TV Show Name'</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Number of Shared Actors'</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="part-4b-summary-and-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="part-4b-summary-and-takeaways">Part 4B: Summary and takeaways</h2>
<p>Wow! Now we have a visualization for a recommender system based on Legally Blonde. I am shocked there are so many true crime shows on there! I guess Reese Witherspoon really stuck to the “Legal” movie genre. Good for her! She’s such a slay girlboss queen.</p>
<p>Something else that is pretty cool about this visualization is that it not only shows you <em>which</em> movies and TV shows are recommended for you, but at <em>which level</em> they are recommended for you based on the number of actors.</p>
<p>Note that you can do this for any movie of your choice using the scraper we built!</p>
<section id="thanks-for-reading-and-remember-whoever-said-orange-is-the-new-pink-was-seriously-disturbed." class="level3">
<h3 class="anchored" data-anchor-id="thanks-for-reading-and-remember-whoever-said-orange-is-the-new-pink-was-seriously-disturbed.">Thanks for reading!! And remember: Whoever said orange is the new pink was <em>seriously</em> disturbed.</h3>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>